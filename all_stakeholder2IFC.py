"""This script creates IFCProject and site and introduces the surrounding model and terrain
to the correct height form the DGM. It takes the surrounding buildings form the script
addGMLbuild.py and adds it to the same site and project as the surrounding model, BL and BG
"""
from ifcopenshell.guid import new as new_guid
import time
from dataclasses import dataclass
from typing import List, Tuple
import numpy as np
import rasterio
from owslib.wcs import WebCoverageService
from Xplan2IFC import main as xplan_main
from addGMLbuild import CityGML2IFC
import os
import ifcopenshell

def create_ifc_project(schema="IFC4X3_ADD2"):
    ifc = ifcopenshell.file(schema=schema)
    ifc.header.file_description.description = ("ViewDefinition [ReferenceView]",)
    ifc.header.file_description.implementation_level = "2;1"
    ifc.header.file_name.originating_system = "RWTHAachen - Python IFC Exporter - Unified"
    ifc.header.file_name.preprocessor_version = "IfcOpenShell 0.7.0"
    ifc.header.file_name.authorization = "Generated by Python script"

    org = ifc.create_entity("IfcOrganization", Name="RWTHAachen")
    app = ifc.create_entity(
        "IfcApplication",
        ApplicationDeveloper=org,
        Version="1.0.0",
        ApplicationFullName="City2IFCTransformer",
        ApplicationIdentifier="3DSitePlane"
    )
    person = ifc.create_entity("IfcPerson", FamilyName="Ahmad", GivenName="Fatma")
    po = ifc.create_entity("IfcPersonAndOrganization", ThePerson=person, TheOrganization=org)
    owner_hist = ifc.create_entity(
        "IfcOwnerHistory",
        OwningUser=po,
        OwningApplication=app,
        State="READWRITE",
        ChangeAction="ADDED",
        LastModifiedDate=int(time.time()),
        CreationDate=int(time.time())
    )

    # Units
    length_unit = ifc.create_entity("IfcSIUnit", UnitType="LENGTHUNIT", Name="METRE")
    area_unit = ifc.create_entity("IfcSIUnit", UnitType="AREAUNIT", Name="SQUARE_METRE")
    volume_unit = ifc.create_entity("IfcSIUnit", UnitType="VOLUMEUNIT", Name="CUBIC_METRE")
    angle_unit = ifc.create_entity("IfcSIUnit", UnitType="PLANEANGLEUNIT", Name="RADIAN")
    units = ifc.create_entity("IfcUnitAssignment", Units=[length_unit, area_unit, volume_unit, angle_unit])

    origin = ifc.create_entity("IfcCartesianPoint", [0.0, 0.0, 0.0])
    placement = ifc.create_entity("IfcAxis2Placement3D", Location=origin)
    context = ifc.create_entity(
        "IfcGeometricRepresentationContext",
        ContextIdentifier="Body",
        ContextType="Model",
        CoordinateSpaceDimension=3,
        Precision=0.01,
        WorldCoordinateSystem=placement
    )
    # Create base context
    geom_context = ifc.createIfcGeometricRepresentationContext(
        ContextIdentifier=None,
        ContextType="Model",
        CoordinateSpaceDimension=3,
        Precision=0.01,
        WorldCoordinateSystem=ifc.createIfcAxis2Placement3D(
            ifc.createIfcCartesianPoint((0.0, 0.0, 0.0)),
            None,
            None
        ),
        TrueNorth=ifc.createIfcDirection((0.0, 1.0, 0.0))
    )

    # Subcontexts
    subcontext_axis = ifc.createIfcGeometricRepresentationSubContext(
        ContextIdentifier="Axis",
        ContextType="Model",
        ParentContext=geom_context,
        TargetView="MODEL_VIEW"
    )
    subcontext_body = ifc.createIfcGeometricRepresentationSubContext(
        ContextIdentifier="Body",
        ContextType="Model",
        ParentContext=geom_context,
        TargetView="MODEL_VIEW"
    )


    project = ifc.create_entity(
        "IfcProject",
        GlobalId=new_guid(),
        Name="SitePlan3D",
        RepresentationContexts=[context],
        UnitsInContext=units,
        OwnerHistory=owner_hist
    )
    site_placement = ifc.create_entity("IfcLocalPlacement", RelativePlacement=placement)
    site = ifc.create_entity("IfcSite", GlobalId=new_guid(), Name="PlanningSite", ObjectPlacement=site_placement)
    building_placement = ifc.create_entity("IfcLocalPlacement", RelativePlacement=placement)
    building = ifc.create_entity("IfcBuilding", GlobalId=new_guid(), OwnerHistory=owner_hist, Name="Planned_Building", ObjectPlacement=building_placement)
    storey_placement = ifc.create_entity("IfcLocalPlacement", RelativePlacement=placement)
    storey = ifc.create_entity("IfcBuildingStorey", GlobalId=new_guid(), OwnerHistory=owner_hist, Name="level_1", ObjectPlacement=storey_placement)

    # Aggregates
    ifc.create_entity("IfcRelAggregates", GlobalId=new_guid(), RelatingObject=project, RelatedObjects=[site])
    ifc.create_entity("IfcRelAggregates", GlobalId=new_guid(), RelatingObject=site, RelatedObjects=[building])
    ifc.create_entity("IfcRelAggregates", GlobalId=new_guid(), RelatingObject=building, RelatedObjects=[storey])

    return ifc, context, project, site, building, storey, owner_hist, subcontext_body, subcontext_axis

def create_fill_style(ifc):
    """Creates a yellow diagonal hatch fill style."""
    yellow = ifc.create_entity("IfcColourRgb", Red=1.0, Green=1.0, Blue=0.0)
    curve_font = ifc.create_entity("IfcDraughtingPreDefinedCurveFont", Name="continuous")
    curve_style = ifc.create_entity("IfcCurveStyle", CurveFont=curve_font, CurveWidth=None, CurveColour=yellow)
    hatch_spacing = ifc.create_entity("IfcPositiveLengthMeasure", 1000.0)
    fill_hatching = ifc.create_entity(
        "IfcFillAreaStyleHatching",
        HatchLineAppearance=curve_style,
        StartOfNextHatchLine=hatch_spacing,
        HatchLineAngle=45.0
    )
    fill_style = ifc.create_entity("IfcFillAreaStyle", Name="FillStyle", FillStyles=[fill_hatching])
    return fill_style

def create_site_fill_area(ifc, points, fill_style=None):
    """Creates a fill area for the site polygon and attaches the fill style."""
    if len(points) < 3:
        return None
    if points[0] == points[-1]:
        points = points[:-1]

    ifc_points = [ifc.create_entity("IfcCartesianPoint", Coordinates=[float(c) for c in pt]) for pt in points]
    ifc_points.append(ifc_points[0])  # close the loop

    polyline = ifc.create_entity("IfcPolyline", Points=ifc_points)
    fill_area = ifc.create_entity("IfcAnnotationFillArea", OuterBoundary=polyline)
    if fill_style:
        ifc.create_entity("IfcStyledItem", Item=fill_area, Styles=[fill_style])
    return fill_area
def create_site_solid(ifc, points, context, site, Z_min=0.0):
    """Create a solid site footprint from polygon points, with Z_max = Z_min + 12"""
    Z_max = Z_min + 12.0  # always 12 meters above Z_min

    if len(points) < 3:
        return None
    if points[0] == points[-1]:
        points = points[:-1]

    bottom_points = [(pt[0], pt[1], Z_min) for pt in points]
    top_points = [(pt[0], pt[1], Z_max) for pt in points]

    def create_ifc_points(pt_list):
        return [ifc.create_entity("IfcCartesianPoint", Coordinates=tuple(float(c) for c in pt)) for pt in pt_list]

    # Bottom, top, sides
    bottom_face = ifc.create_entity(
        "IfcFace",
        Bounds=[ifc.create_entity(
            "IfcFaceOuterBound",
            Bound=ifc.create_entity("IfcPolyLoop", Polygon=create_ifc_points(bottom_points)),
            Orientation=True
        )]
    )
    top_face = ifc.create_entity(
        "IfcFace",
        Bounds=[ifc.create_entity(
            "IfcFaceOuterBound",
            Bound=ifc.create_entity("IfcPolyLoop", Polygon=create_ifc_points(top_points)),
            Orientation=True
        )]
    )
    side_faces = []
    n = len(points)
    for i in range(n):
        p1b, p2b = bottom_points[i], bottom_points[(i + 1) % n]
        p1t, p2t = top_points[i], top_points[(i + 1) % n]
        side_face_pts = [p1b, p2b, p2t, p1t]
        side_face = ifc.create_entity(
            "IfcFace",
            Bounds=[ifc.create_entity(
                "IfcFaceOuterBound",
                Bound=ifc.create_entity("IfcPolyLoop", Polygon=create_ifc_points(side_face_pts)),
                Orientation=True
            )]
        )
        side_faces.append(side_face)

    cfs = ifc.create_entity("IfcConnectedFaceSet", CfsFaces=[bottom_face, top_face] + side_faces)
    surface_model = ifc.create_entity("IfcFaceBasedSurfaceModel", FbsmFaces=[cfs])
    shape_rep = ifc.create_entity(
        "IfcShapeRepresentation",
        ContextOfItems=context,
        RepresentationIdentifier="Footprint",
        RepresentationType="SurfaceModel",
        Items=[surface_model]
    )
    site.Representation = ifc.create_entity(
        "IfcProductDefinitionShape",
        Representations=[shape_rep]
    )

def create_virtual_element(ifc, points, context, storey, name="VirtualElement"):
    if len(points) < 3:
        return None
    seen = set()
    cleaned_pts = []
    for pt in points:
        key = tuple(round(c, 6) for c in pt)
        if key not in seen:
            cleaned_pts.append(pt)
            seen.add(key)
    if len(cleaned_pts) < 3:
        return None
    ifc_points = [ifc.create_entity("IfcCartesianPoint", Coordinates=[float(c) for c in pt]) for pt in cleaned_pts]
    polyloop = ifc.create_entity("IfcPolyLoop", Polygon=ifc_points)
    outer_bound = ifc.create_entity("IfcFaceOuterBound", Bound=polyloop, Orientation=True)
    face = ifc.create_entity("IfcFace", Bounds=[outer_bound])
    cfs = ifc.create_entity("IfcConnectedFaceSet", CfsFaces=[face])
    surface_model = ifc.create_entity("IfcFaceBasedSurfaceModel", FbsmFaces=[cfs])
    shape_rep = ifc.create_entity("IfcShapeRepresentation", ContextOfItems=context, RepresentationIdentifier="Body", RepresentationType="SurfaceModel", Items=[surface_model])
    prod_def = ifc.create_entity("IfcProductDefinitionShape", Representations=[shape_rep])
    virtual = ifc.create_entity("IfcAnnotation", GlobalId=new_guid(), Name=name, ObjectPlacement=storey.ObjectPlacement, Representation=prod_def)
    ifc.create_entity("IfcRelContainedInSpatialStructure", GlobalId=new_guid(), RelatingStructure=storey, RelatedElements=[virtual])

@dataclass
class WCSConfig:
    url: str
    version: str = "2.0.1"
    coverage_id: str = "nw_dgm"
    format: str = "image/tiff"

class BBoxBuilder:
    def __init__(self, origin_x: float, origin_y: float):
        self.origin_x = origin_x
        self.origin_y = origin_y
    def from_local_points(self, points: List[Tuple[float, float]], margin: float) -> List[float]:
        pts = np.array(points)
        if pts.size == 0:
            raise ValueError("No points for BBOX")
        min_xy = pts.min(axis=0)
        max_xy = pts.max(axis=0)
        return [self.origin_x + min_xy[0] - margin, self.origin_y + min_xy[1] - margin,
                self.origin_x + max_xy[0] + margin, self.origin_y + max_xy[1] + margin]

class WCSTerrainSource:
    def __init__(self, config: WCSConfig):
        self.wcs = WebCoverageService(config.url, version=config.version)
        self.coverage_id = config.coverage_id
        self.format = config.format
    def download(self, bbox: List[float], out_path: str):
        clean = [round(float(v), 3) for v in bbox]
        response = self.wcs.getCoverage(
            identifier=[self.coverage_id],
            subsets=[
                ('x', clean[0], clean[2]),
                ('y', clean[1], clean[3]),
            ],
            format=self.format,
        )

        with open(out_path, "wb") as f:
            f.write(response.read())

class TerrainMesh:
    def from_geotiff(self, path, utm_origin_x, utm_origin_y, step=2):
        with rasterio.open(path) as src:
            elevations = src.read(1)
            transform = src.transform
        n_rows, n_cols = elevations.shape
        n_rows_ds = (n_rows - 1) // step + 1
        n_cols_ds = (n_cols - 1) // step + 1
        vertices = []
        for r in range(0, n_rows, step):
            for c in range(0, n_cols, step):
                x, y = rasterio.transform.xy(transform, r, c)
                z = float(elevations[r, c])
                vertices.append([float(x - utm_origin_x), float(y - utm_origin_y), z])
        faces = []
        def idx(r, c): return r * n_cols_ds + c
        for r in range(n_rows_ds - 1):
            for c in range(n_cols_ds - 1):
                faces.append([idx(r, c), idx(r + 1, c), idx(r, c + 1)])
                faces.append([idx(r, c + 1), idx(r + 1, c), idx(r + 1, c + 1)])
        return vertices, faces

class IFCTerrainWriter:
    """
    Unified terrain writer for IFC.
    Can add terrain mesh to an existing IFC model and context.
    """
    def __init__(self, ifc_model, context, site):
        """
        ifc_model : ifcopenshell.file - existing IFC project
        context   : IFC geometric representation context (e.g., from create_ifc_project)
        site      : IFC site element to attach the terrain
        """
        self.model = ifc_model
        self.context = context
        self.site = site

    def add_terrain(self, vertices, faces, name="Terrain"):
        """
        Add a terrain mesh as an IfcGeographicElement to the IFC.
        vertices : list of [x, y, z]
        faces    : list of index triples [i0, i1, i2]
        """
        # --- Cartesian points and faces ---
        cart_points = self.model.create_entity("IfcCartesianPointList3D", CoordList=vertices)
        polygon_faces = [
            self.model.create_entity("IfcIndexedPolygonalFace", [i + 1 for i in face])
            for face in faces
        ]
        face_set = self.model.create_entity(
            "IfcPolygonalFaceSet",
            Coordinates=cart_points,
            Faces=polygon_faces
        )

        # --- Shape representation ---
        shape_rep = self.model.create_entity(
            "IfcShapeRepresentation",
            ContextOfItems=self.context,
            RepresentationType="Tessellation",
            RepresentationIdentifier="Body",
            Items=[face_set]
        )

        # --- Product definition shape ---
        prod_def = self.model.create_entity(
            "IfcProductDefinitionShape",
            Representations=[shape_rep]
        )

        # --- Create terrain entity attached to site ---
        terrain = self.model.create_entity(
            "IfcGeographicElement",
            GlobalId=new_guid(),
            Name=name,
            ObjectPlacement=self.site.ObjectPlacement,
            Representation=prod_def
        )

        # --- Aggregate in site ---
        self.model.create_entity(
            "IfcRelAggregates",
            GlobalId=new_guid(),
            RelatingObject=self.site,
            RelatedObjects=[terrain]
        )
def export_ifc_unified(filename=str):
    from Xplan2IFC import main

    data = main()
    flurstueck_dict = data.get("flurstueck_dict", {})
    baugrenze_dict = data.get("baugrenze_dict", {})
    baulinie_dict = data.get("baulinie_dict", {})
    generator = data["generator"]

    all_points = []
    for item in flurstueck_dict.values():
        all_points.extend(item["points"])
    bbox = BBoxBuilder(generator.origin_x, generator.origin_y).from_local_points(all_points, margin=20.0)

    wcs_source = WCSTerrainSource(WCSConfig(url="https://www.wcs.nrw.de/geobasis/wcs_nw_dgm"))
    wcs_source.download(bbox, "nrw_dgm.tif")

    terrain_mesh = TerrainMesh()
    vertices, faces = terrain_mesh.from_geotiff("nrw_dgm.tif", generator.origin_x, generator.origin_y, step=2)

    # Compute terrain Z_min for FlurstÃ¼cks
    terrain_z_values = [v[2] for v in vertices]
    terrain_z_min = min(terrain_z_values)

    # Create IFC project
    ifc, context, project, site, building, storey, owner_hist, context_b, context_a = create_ifc_project()
    fill_style = create_fill_style(ifc)
    if all_points:
        create_site_solid(ifc, all_points, context, site, Z_min=terrain_z_min)

    Z_min_face = terrain_z_min
    Z_max_face = Z_min_face + 12.0

    writer = IFCTerrainWriter(ifc_model=ifc, context=context, site=site)
    writer.add_terrain(vertices, faces, name="NRW_DGM1")

    for geom_dict, label in [(baugrenze_dict, "BG"), (baulinie_dict, "BL")]:
        for key, item in geom_dict.items():
            points = item["points"]
            name = item.get("name", f"{label}_{key}")
            for i in range(len(points) - 1):
                p1, p2 = points[i], points[i + 1]
                face_pts = [
                    (p1[0], p1[1], Z_min_face),
                    (p2[0], p2[1], Z_min_face),
                    (p2[0], p2[1], Z_max_face),
                    (p1[0], p1[1], Z_max_face)
                ]
                unique_pts = []
                for pt in face_pts:
                    if not unique_pts or pt != unique_pts[-1]:
                        unique_pts.append(pt)
                if len(unique_pts) >= 3:
                    create_virtual_element(ifc, unique_pts, context, site, name=f"{name}_face_{i+1}")
    script_dir = os.path.dirname(os.path.abspath(__file__))
    data_folder = os.path.join(script_dir, "data")
    citygml_source = os.path.join(data_folder, "Lod2existingbuilding.gml")
    result_ifc = os.path.join(script_dir, "site_full.ifc")
    transformer = CityGML2IFC(
        path = citygml_source,
        existing_ifc= ifc,
        project_obj=project,
        site_main=site
        )
    transformer.write(result_ifc)
    #ifc.write(result_ifc)
if __name__ == "__main__":
    export_ifc_unified()
